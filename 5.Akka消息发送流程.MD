消息发送的流程：
```scala
actor ! "msg"
```
> LocalActorRef类，！方法的实现
```scala
override def !(message: Any)(implicit sender: ActorRef = Actor.noSender): Unit = actorCell.sendMessage(message, sender)
```
> ActorCell类
```scala
final def sendMessage(message: Any, sender: ActorRef): Unit =
    sendMessage(Envelope(message, sender, system))
```
> Dispatch trait
```scala
  def sendMessage(msg: Envelope): Unit =
    try {
      if (system.settings.SerializeAllMessages) {
        val unwrapped = (msg.message match {
          case DeadLetter(wrapped, _, _) ⇒ wrapped
          case other                     ⇒ other
        }).asInstanceOf[AnyRef]
        if (!unwrapped.isInstanceOf[NoSerializationVerificationNeeded]) {
          val s = SerializationExtension(system)
          val serializer = s.findSerializerFor(unwrapped)
          val bytes = serializer.toBinary(unwrapped)
          serializer match {
            case ser2: SerializerWithStringManifest ⇒
              val manifest = ser2.manifest(unwrapped)
              s.deserialize(bytes, serializer.identifier, manifest).get != null
            case _ ⇒
              s.deserialize(bytes, unwrapped.getClass).get
          }
        }
      }
      dispatcher.dispatch(this, msg)
    } catch handleException
```
> Dispatcher类
```scala
  protected[akka] def dispatch(receiver: ActorCell, invocation: Envelope): Unit = {
    //获得接受者的邮箱
    val mbox = receiver.mailbox
    //将接受者的ActorRef对象以及信封Envelope添加到邮箱的消息队列中
    mbox.enqueue(receiver.self, invocation)
    //将邮箱交给线程池中的线程执行，如果失败还会尝试再执行一遍
    registerForExecution(mbox, true, false)
  }
```
```scala
  protected[akka] override def registerForExecution(mbox: Mailbox, hasMessageHint: Boolean, hasSystemMessageHint: Boolean): Boolean = {
    if (mbox.canBeScheduledForExecution(hasMessageHint, hasSystemMessageHint)) { 
      if (mbox.setAsScheduled()) {
        try {
          executorService execute mbox
          true
        } catch {
          case e: RejectedExecutionException ⇒
            try {
              executorService execute mbox
              true
            } catch { //Retry once
              case e: RejectedExecutionException ⇒
                mbox.setAsIdle()
                eventStream.publish(Error(e, getClass.getName, getClass, "registerForExecution was rejected twice!"))
                throw e
            }
        }
      } else false
    } else false
  }
```

> Mailbox继承Runnable，因此可以将Mailbox交给线程池中的线程执行。
> Mailbox的run方法：
```scala
  override final def run(): Unit = {
    try {
      if (!isClosed) { //Volatile read, needed here
        //处理所有的系统消息
        processAllSystemMessages() 
        //处理邮箱中的消息
        processMailbox() 
      }
    } finally {
      setAsIdle() //Volatile write, needed here
      dispatcher.registerForExecution(this, false, false)
    }
  }
```

> Mailbox的processMailbox方法：
```scala
  @tailrec private final def processMailbox(
    left: Int = java.lang.Math.max(dispatcher.throughput, 1),
    deadlineNs: Long = if (dispatcher.isThroughputDeadlineTimeDefined == true) System.nanoTime + dispatcher.throughputDeadlineTime.toNanos else 0L): Unit =
    if (shouldProcessMessage) {
      // 从MessageQueue中取出信封Envelope
      val next = dequeue()
      if (next ne null) {
        if (Mailbox.debug) println(actor.self + " processing message " + next)
        // 调用ActorCell的invoke方法处理Envelope
        actor invoke next
        //在把Mailbox交给线程池中的线程运行过程中，会响应中断
        if (Thread.interrupted())
          throw new InterruptedException("Interrupted while processing actor messages")
        processAllSystemMessages()
        if ((left > 1) && ((dispatcher.isThroughputDeadlineTimeDefined == false) || (System.nanoTime - deadlineNs) < 0))
          //此处说明了，线程在切换到另一个Actor去处理其他Actor邮箱中消息之前，处理当前Actor的邮箱中消息的数目上限
          processMailbox(left - 1, deadlineNs)
      }
    }
```

> ActorCell类的invoke方法:
```scala
  final def invoke(messageHandle: Envelope): Unit = {
    val influenceReceiveTimeout = !messageHandle.message.isInstanceOf[NotInfluenceReceiveTimeout]
    try {
      currentMessage = messageHandle
      if (influenceReceiveTimeout)
        cancelReceiveTimeout()
      messageHandle.message match {
        //处理自动接受的消息
        case msg: AutoReceivedMessage ⇒ autoReceiveMessage(messageHandle)
        //处理正常接受的消息
        case msg                      ⇒ receiveMessage(msg)
      }
      currentMessage = null // reset current message after successful invocation
    } catch handleNonFatalOrInterruptedException { e ⇒
      handleInvokeFailure(Nil, e)
    } finally {
      if (influenceReceiveTimeout)
        checkReceiveTimeout // Reschedule receive timeout
    }
  }
```
> 处理正常接受消息的逻辑：
> 首先，看看ActorCell类中的receiveMessage方法
```scala
final def receiveMessage(msg: Any): Unit = actor.aroundReceive(behaviorStack.head, msg)
```
> 然后，看看Actor类的aroundRecevie方法
```scala
//可以看到，首先是将消息应用到receive方法中，如果不匹配，就应用到unhandled方法中
protected[akka] def aroundReceive(receive: Actor.Receive, msg: Any): Unit = receive.applyOrElse(msg, unhandled)
```
> 处理自动接受到的消息的逻辑
> 首先，看看ActorCell中的autoReceiveMessage方法
```scala
  def autoReceiveMessage(msg: Envelope): Unit = {
    if (system.settings.DebugAutoReceive)
      publish(Debug(self.path.toString, clazz(actor), "received AutoReceiveMessage " + msg))
    //此处列举出了所有自动过接受的消息的种类，以及相应的处理
    msg.message match {
      case t: Terminated              ⇒ receivedTerminated(t)
      case AddressTerminated(address) ⇒ addressTerminated(address)
      case Kill                       ⇒ throw new ActorKilledException("Kill")
      case PoisonPill                 ⇒ self.stop()
      case sel: ActorSelectionMessage ⇒ receiveSelection(sel)
      case Identify(messageId)        ⇒ sender() ! ActorIdentity(messageId, Some(self))
    }
  }
```



